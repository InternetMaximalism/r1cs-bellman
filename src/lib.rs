use std::collections::{HashSet,BTreeMap};
use std::iter::FromIterator;
use bellman::{Circuit, ConstraintSystem, LinearCombination, SynthesisError, Variable};
use bellman::Index::{Aux, Input};
use bellman::SynthesisError::{AssignmentMissing};
use pairing::Engine;
use r1cs::{Constraint, Element, Expression, Field, Gadget, Wire, Bls12_381};
use ff::PrimeField;
use std::marker::PhantomData;
use bls12_381::{Bls12};
use num::{BigUint, Integer, One, ToPrimitive};

pub trait FieldConverter<F: Field, E: Engine> {
    fn convert_field(n: &Element<F>) -> E::Fr;
}

pub struct WrappedCircuit<F: Field, E: Engine, C:FieldConverter<F,E>> {
    gadget: Gadget<F>,
    n_wire: usize,
    witness_map: BTreeMap<u32,E::Fr>,
    public_inputs: Vec<Wire>,
    _c: PhantomData<C>
}

impl<F: Field, E: Engine, C:FieldConverter<F,E>> Circuit<E::Fr> for WrappedCircuit<F, E, C> {
    fn synthesize<CS: ConstraintSystem<E::Fr>>(self, cs: &mut CS) -> Result<(), SynthesisError> {
        let WrappedCircuit { gadget, n_wire, witness_map, public_inputs, _c} = self;
        let public_inputs = HashSet::from_iter(public_inputs);
        let mut variable_map: BTreeMap<Wire,Variable> = BTreeMap::<Wire,Variable>::new();
        for i in 0..n_wire {
            let wire_index = (i+1) as u32;
            let wire = Wire{index:wire_index};
            let variable = Self::_generate_variable(cs, wire, &witness_map, &public_inputs);
            variable_map.insert(wire, variable);
        }
        let mut i=0;
        for constraint in gadget.constraints {
            let Constraint { a, b, c } = constraint;
            let a_lc = Self::_convert_lc::<CS>(cs, a, &variable_map, &public_inputs);
            let b_lc = Self::_convert_lc::<CS>(cs, b, &variable_map, &public_inputs);
            let c_lc = Self::_convert_lc::<CS>(cs, c, &variable_map, &public_inputs);
            cs.enforce(
                || format!("generated by r1cs-bellman at {}", i),
                |_| a_lc,
                |_| b_lc,
                |_| c_lc,
            );
            i += 1;
        }
        Ok(())
    }
}

impl<F: Field, E: Engine, C:FieldConverter<F,E>> WrappedCircuit<F, E, C> {
    pub fn new(
        gadget: Gadget<F>,
        n_wire: usize,
        witness_map: BTreeMap<u32,E::Fr>,
        public_inputs: Vec<Wire>
    ) -> Self {
        Self {
            gadget,
            n_wire,
            witness_map,
            public_inputs,
            _c: PhantomData
        }
    }

    pub fn gadget(&self) -> &Gadget<F> {
        &self.gadget
    }

    pub fn n_wire(&self) -> usize {
        self.n_wire.clone()
    }

    pub fn witness_map(&self) -> &BTreeMap<u32,E::Fr> {
        &self.witness_map
    }

    pub fn public_inputs(&self) -> &Vec<Wire> {
        &self.public_inputs
    }

    fn _convert_lc<CS: ConstraintSystem<E::Fr>>(
        cs: &mut CS,
        exp: Expression<F>,
        variable_map: &BTreeMap<Wire,Variable>,
        public_inputs: &HashSet<Wire>
    ) -> LinearCombination<E::Fr> {
        // This is inefficient, but bellman doesn't expose a LinearCombination constructor taking an
        // entire variable/coefficient map, so we have to build one up with repeated addition.
        let mut sum = LinearCombination::zero();
        for (wire, coeff) in exp.coefficients() {
            let fr = C::convert_field(coeff);
            let var = *variable_map.get(wire).unwrap();
            sum = sum + (fr, var);
        }
        sum
    }
    
    fn _generate_variable<CS: ConstraintSystem<E::Fr>>(
        cs: &mut CS,
        wire: Wire,
        witness_map: &BTreeMap<u32,E::Fr>,
        public_inputs: &HashSet<Wire>
    ) -> Variable {
        let wire_index = wire.index;
        let witness = witness_map.get(&wire_index);
        let is_public = public_inputs.contains(&wire);
        
        match witness {
            Some(wtns) => {
                if is_public {
                    cs.alloc_input(|| "public input", || Ok(*wtns)).unwrap()
                } else {
                    cs.alloc(|| "private input", || Ok(*wtns)).unwrap()
                }
            }
            None => {
                if is_public {
                    cs.alloc_input(|| "public input", || Ok(E::Fr::from_str("0").unwrap())).unwrap()
                } else {
                    cs.alloc(|| "private input", || Ok(E::Fr::from_str("0").unwrap())).unwrap()
                }
            }
        }
    }
}

pub struct Bls12_381Converter;

impl FieldConverter<r1cs::Bls12_381, Bls12> for Bls12_381Converter {
    fn convert_field(n: &Element<r1cs::Bls12_381>) -> <Bls12 as Engine>::Fr {
        let n = n.to_biguint();
        // Bls12::Fr::FrRepr's chunks are little endian.
        let u64_size = BigUint::one() << 64;
        let chunks = [
            n.mod_floor(&u64_size).to_u64().unwrap(),
            (n >> 64).mod_floor(&u64_size).to_u64().unwrap(),
            (n >> 64 * 2).mod_floor(&u64_size).to_u64().unwrap(),
            (n >> 64 * 3).mod_floor(&u64_size).to_u64().unwrap(),
        ];
        <Bls12 as Engine>::Fr::from_repr(bls12_381::Scalar::from_raw(chunks).to_bytes()).unwrap()
    }
}




#[cfg(test)]
mod tests {
    use bellman::groth16::{create_random_proof, generate_random_parameters, prepare_verifying_key, Proof, verify_proof};
    use num::{BigUint, Integer, One, ToPrimitive};
    use bls12_381::{Bls12};
    use ff::PrimeField;
    use pairing::Engine;
    use r1cs::{Bls12_381, Element, Gadget, GadgetBuilder, Expression, Wire};
    use rand::thread_rng;
    use std::collections::{BTreeMap};
    use std::marker::PhantomData;

    use crate::{WrappedCircuit, Bls12_381Converter, FieldConverter};

    #[test]
    fn valid_proof() {
        let rng = &mut thread_rng();

        // Generate random parameters.
        let empty_map = BTreeMap::<u32,<Bls12 as Engine>::Fr>::new();
        let circuit = build_circuit(empty_map);
        let params = generate_random_parameters::<Bls12, _, _>(circuit, rng).unwrap();
        let pvk = prepare_verifying_key(&params.vk);

        // Generate a random proof.
        let mut witness_map = BTreeMap::<u32,<Bls12 as Engine>::Fr>::new();
        //1*6 = 6
        witness_map.insert(1,Bls12_381Converter::convert_field(&Element::from(2u8)));
        witness_map.insert(2,Bls12_381Converter::convert_field(&Element::from(3u8)));
        witness_map.insert(3,Bls12_381Converter::convert_field(&Element::from(6u8)));
        let circuit = build_circuit(witness_map);
        let proof = create_random_proof(circuit, &params, rng).unwrap();

        // Serialize and deserialize the proof.
        let mut proof_out = vec![];
        proof.write(&mut proof_out).unwrap();
        let proof = Proof::read(&proof_out[..]).unwrap();

        // Verify the proof.
        let public_inputs = &[Bls12_381Converter::convert_field(&Element::from(6u8))];
        verify_proof(&pvk, &proof, public_inputs).unwrap();
        assert!(verify_proof(&pvk, &proof, public_inputs).is_ok());
    }

    #[test]
    fn invalid_proof() {
        let rng = &mut thread_rng();

        // Generate random parameters.
        let empty_map = BTreeMap::<u32,<Bls12 as Engine>::Fr>::new();
        let circuit = build_circuit(empty_map);
        let params = generate_random_parameters::<Bls12, _, _>(circuit, rng).unwrap();
        let pvk = prepare_verifying_key(&params.vk);

        // Generate a random proof.
        let mut witness_map = BTreeMap::<u32,<Bls12 as Engine>::Fr>::new();
        // 2*6 != 6
        witness_map.insert(1,Bls12_381Converter::convert_field(&Element::from(4u8)));
        witness_map.insert(2,Bls12_381Converter::convert_field(&Element::from(6u8)));
        witness_map.insert(3,Bls12_381Converter::convert_field(&Element::from(6u8)));
        let circuit = build_circuit(witness_map);
        let proof = create_random_proof(circuit, &params, rng).unwrap();

        // Serialize and deserialize the proof.
        let mut proof_out = vec![];
        proof.write(&mut proof_out).unwrap();
        let proof = Proof::read(&proof_out[..]).unwrap();

        // Verify the proof.
        let public_inputs = &[Bls12_381Converter::convert_field(&Element::from(6u8))];
        assert!(verify_proof(&pvk, &proof, public_inputs).is_err());
    }

    fn build_circuit(witness_map: BTreeMap<u32,<Bls12 as Engine>::Fr>) -> WrappedCircuit<r1cs::Bls12_381, bls12_381::Bls12, Bls12_381Converter> {
        let mut builder = GadgetBuilder::<Bls12_381>::new();
        let x = builder.wire();
        let y = builder.wire();
        let z = builder.wire();
        builder.assert_product(&Expression::from(&x), &Expression::from(&y), &Expression::from(&z));
        let gadget = builder.build();
        WrappedCircuit {
            gadget,
            n_wire:3,
            witness_map,
            public_inputs: vec![z],
            _c: PhantomData
        }
    }


    /*fn convert_bls12_381(n: &Element<r1cs::Bls12_381>) -> <Bls12 as Engine>::Fr {
        let n = n.to_biguint();
        // Bls12::Fr::FrRepr's chunks are little endian.
        let u64_size = BigUint::one() << 64;
        let chunks = [
            n.mod_floor(&u64_size).to_u64().unwrap(),
            (n >> 64).mod_floor(&u64_size).to_u64().unwrap(),
            (n >> 64 * 2).mod_floor(&u64_size).to_u64().unwrap(),
            (n >> 64 * 3).mod_floor(&u64_size).to_u64().unwrap(),
        ];
        <Bls12 as Engine>::Fr::from_repr(bls12_381::Scalar::from_raw(chunks).to_bytes()).unwrap()
    }*/
}